// shared JS functions for sync forms
var base_url = "https://notebooks.firecloud.org/";

// function to make synchronous api requests
// TODO make this asynchronous, change last param of open to true instead of false and change handling of return for all calls
function syncApiRequest(endpoint, base_url, method, headers, body, includeCookies, async) {
    // create the request
    var request = new XMLHttpRequest();
    // format the api url
    var url = base_url + endpoint;
    // open the request to get inital params
    if(async){
        request.open(method, url, true);
    } else {
        request.open(method, url, false);
    }

    // TODO make sure this works
    // if includeCookies (used for setCookie) enable xmlhttprequest with credential option
    if (includeCookies) {
        request.withCredentials = true;
    }
    // add the headers to the request
    for (var header in headers) {
        request.setRequestHeader(header, headers[header])
    }
    // payload handling
    if (body) {
        // if a payload exists I pass it in as a dictionary, set the content type
        // and add the parsed payload to the request
        request.setRequestHeader('Content-type', "application/json");
        request.send(JSON.stringify(body));
    } else {
        // if no body exists we can skip parsing it
        if(!async){
            request.send();
        }
    }
    // return the request object
    return request
}

// may have to use this function in the future to test if api is working
function ping(headers) {
    var endpoint = "ping";
    var method = "GET";
    return (syncApiRequest(endpoint, base_url, method, headers))
}

function clusterOptions(googleProject, clusterName, headers, body, includesCookies, async) {
    var endpoint = "api/cluster/" + googleProject + "/" + clusterName;
    var method = "GET";
    return (syncApiRequest(endpoint, base_url, method, headers, body, includesCookies, async))
}

function createCluster(googleProject, clusterName, headers, body) {
    var endpoint = "api/cluster/" + googleProject + "/" + clusterName;
    var method = "PUT";
    return (syncApiRequest(endpoint, base_url, method, headers, body))
}

function deleteCluster(googleProject, clusterName, headers) {
    var endpoint = "api/cluster/" + googleProject + "/" + clusterName;
    var method = "DELETE";
    return (syncApiRequest(endpoint, base_url, method, headers))
}

function startCluster(googleProject, clusterName, headers, body, includesCookies, async) {
    var endpoint = "api/cluster/" + googleProject + "/" + clusterName + "/start";
    var method = "POST";
    return (syncApiRequest(endpoint, base_url, method, headers, body, includesCookies, async))
}

function stopCluster(googleProject, clusterName, headers) {
    var endpoint = "api/cluster/" + googleProject + "/" + clusterName + "/stop";
    var method = "POST";
    return (syncApiRequest(endpoint, base_url, method, headers))
}

function listClusters(clusterName, headers) {
    var endpoint = "api/clusters";
    var method = "GET";
    return (syncApiRequest(endpoint, base_url, method, headers))
}

function localizeFiles(googleProject, clusterName, headers, body) {
    var endpoint = "notebooks/"+ googleProject + "/" + clusterName + "/api/localize";
    var method = "POST";
    return (syncApiRequest(endpoint, base_url, method, headers, body))
}

function getNotebook(googleProject, clusterName, headers) {
    var endpoint = "notebooks/" + googleProject + "/" + clusterName + "/tree?" ;
    var method = "GET";
    return (syncApiRequest(endpoint, base_url, method, headers, undefined, undefined, true))
}

function setCookie(googleProject, clusterName, headers) {
    var endpoint = "notebooks/" + googleProject + "/" + clusterName + "/setCookie";
    var method = "GET";
    return (syncApiRequest(endpoint, base_url, method, headers, undefined, true))
}

function invalidateCookie(headers) {
    var endpoint = "notebooks/invalidateToken";
    var method = "GET";
    return (syncApiRequest(endpoint, base_url, method, headers))
}

// function to generate datatables object from listCluster api call
function generateDataTable(workspace, headers) {
    // make the api call
    var clusterList = listClusters(workspace, headers);
    var clusterArr = [];
    // if the call was successful parse the json response
    if (clusterList.status === 200) {
        clusterArr = JSON.parse(clusterList.response);
    } else {
        alert("Failed to get get list of clusters")
    }
    // create the data array object
    var tableArr = [];
    for (var i = 0; i < clusterArr.length; i++) {
        // parse the [{}] response, replacing undefined with empty string
        var clusterResponse = clusterArr[i];
        var status = clusterResponse.status ? clusterResponse.status : "";
        var createdDate = clusterResponse.createdDate ? clusterResponse.createdDate : "";
        var masterMachineType = clusterResponse.machineConfig.masterMachineType ? clusterResponse.machineConfig.masterMachineType : "";
        var masterDiskSize = clusterResponse.machineConfig.masterDiskSize ? clusterResponse.machineConfig.masterDiskSize : "";
        var clusterName = clusterResponse.clusterName ? clusterResponse.clusterName : "";
        var numberOfWorkers = clusterResponse.machineConfig.numberOfWorkers ? clusterResponse.machineConfig.numberOfWorkers : "";
        var workerMachineType = clusterResponse.machineConfig.workerMachineType ? clusterResponse.machineConfig.workerMachineType : "";
        var workerDiskSize = clusterResponse.machineConfig.workerDiskSize ? clusterResponse.machineConfig.workerDiskSize : "";
        var numberOfWorkerLocalSSDs = clusterResponse.machineConfig.numberOfWorkerLocalSSDs ? clusterResponse.machineConfig.numberOfWorkerLocalSSDs : "";
        var numberOfPreemptibleWorkers = clusterResponse.machineConfig.numberOfPreemptibleWorkers ? clusterResponse.machineConfig.numberOfPreemptibleWorkers : "";
        var creator = clusterResponse.labels.creator ? clusterResponse.labels.creator : "";
        // add special buttons
        if (status === "Running") {
            // if it is running add the delete button and link to notebook in the name column
            var notebookLink = base_url + "notebooks/" + clusterResponse.googleProject + "/" + clusterName;
            var deleteButton = "<div class='btn btn-sm btn-danger cluster-delete' id='" + clusterName + "'>Delete</div>";
            // add stop button to status
            var stopButton = "<div class='btn btn-sm btn-warning cluster-stop' id='" + clusterName + "'>Stop</div>";
            status = stopButton + status;

            var localizeButton = "<div class='btn btn-sm btn-warning cluster-localize' id='" + clusterName + "'>Localize</div>";
            // add delete button and link to name
            clusterName = deleteButton + "<a class='notebook-link' id='" + clusterName + "' href=\"" + notebookLink + "\" target=\"_blank\">\t" + clusterName + "</a>\t"+localizeButton;

        } else if (status === "Stopped") {
            // if it is stopped add start button to status
            var startButton = "<div class='btn btn-sm btn-success cluster-start' id='" + clusterName + "'>Start</div>";
            status = startButton + status;
            // if it is stopped add delete button to name
            var deleteButton = "<div class='btn btn-sm btn-danger cluster-delete' id='" + clusterName + "'>Delete</div>";
            clusterName = deleteButton + clusterName;
        }
        // add the formatted row to the data array
        tableArr.push([status, createdDate, masterMachineType, clusterName])
    }
    // hide the no columns ui element
    $('#no_clusters_well').hide()
    return tableArr
}

function localizeNotebook(googleProject, clusterName, headers, parsedLocalizeCommands){
    // get the notebook gsurl
    // localize the notebook and other files to the cluster
    // return the link to the notebook
    console.log("Localizing")
    return localizeFiles(googleProject, clusterName, headers, parsedLocalizeCommands)
}

function waitTillRunning(googleProject, clusterName, headers, parsedCreateParams){
    function sleep(delay) {
        var start = new Date().getTime();
        while (new Date().getTime() < start + delay);
    }
    console.log("In Wait till Running")
    var clusterInfo = clusterOptions(googleProject, clusterName, headers, undefined, undefined, false)
    console.log(clusterInfo)
    var i = 0;
    while(clusterInfo){
        if(i>30){
            console.log(clusterInfo)
            return
        }
        console.log("In clusterInfo")
        if (clusterInfo.readyState === 4) {
            if (clusterInfo.status === 200) {
                console.log("200 response")
                // we have the cluster info
                var clusterState = JSON.parse(clusterInfo.response).status;
                console.log("Cluster State" + clusterState);
                if(clusterState === "Running"){
                    // continue
                    return "Running"
                } else if (clusterState === "Stopped") {
                    // start cluster
                    var startRequest = startCluster(workspace, clusterName, headers, undefined, undefined, false);
                    startRequest.onload = function (e) {
                        if (clusterInfo.readyState === 4) {
                            if (clusterInfo.status !== 200) {
                                console.log("Error starting cluster")
                            }
                        }
                    }
                }  else if (clusterState === "Deleting"){
                    // STOP
                    alert("Cannot run notebook on deleting Cluster");
                    return "Deleting"
                }
            } else {
                console.log("Error opening notebook in cluster, trying to create it")
                var create = createCluster(googleProject, clusterName, headers, parsedCreateParams);
            }

        }

        sleep(20000);
        console.log("getting new cluster info")
        clusterInfo = clusterOptions(googleProject, clusterName, headers);
        i ++;
    }
  console.log(clusterInfo);
  return "Error"
}

function openNotebook(googleProject, clusterName, headers, notebook, parsedCreateParams, parsedLocalizeCommands){
    // first get the cluster info to make sure it is running
    console.log("In Open Notebook")
    var status = waitTillRunning(googleProject, clusterName, headers, parsedCreateParams)
    console.log("No Longer Waiting")
    if(status === "Running"){
        console.log("In Running")
        var localize = localizeNotebook(googleProject, clusterName, headers, parsedLocalizeCommands)
        if(localize.status === 200){
            // notebooks/single-cell-portal/iframescp/notebooks/cellranger_orchestra_pipeline.ipynb
            $('#notebookModal').modal('toggle');
            return "notebooks/" + googleProject + "/" + clusterName + "/notebooks/" + notebook;
        }
    } else{
        console.log(status)
        alert("Error starting notebook")
    }

}